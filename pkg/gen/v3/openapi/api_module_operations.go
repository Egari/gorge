/*
 * Puppet Forge v3 API
 *
 * ## Introduction The Puppet Forge API (hereafter referred to as the Forge API) provides quick access to all the data on the Puppet Forge via a RESTful interface. Using the Forge API, you can write scripts and tools that interact with the Puppet Forge website.  The Forge API's current version is `v3`. It is considered regression-stable, meaning that the returned data is guaranteed to include the fields described in the schemas on this page; however, additional data might be added in the future and clients must ignore any properties they do not recognize.  ## OpenAPI Specification The Puppet Forge v3 API is described by an [OpenAPI 3.0](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md) formatted specification file. The most up-to-date version of this specification file can be accessed at [https://forgeapi.puppet.com/v3/openapi.json](/v3/openapi.json).  ## Features * The API is accessed over HTTPS via either the `forgeapi.puppet.com` (IPv4 or IPv6). All data is returned in JSON   format. * Blank fields are included as `null`. * Nested resources may use an abbreviated representation. A link to the full representation for the   resource is always included. * All timestamps in JSON responses are returned in ISO 8601 format: `YYYY-MM-DD HH:MM:SS Â±HHMM`. * The HTTP response headers include caching hints for conditional requests.  ## Concepts and Terminology * **Module**: Modules are self-contained bundles of code and data with a specific directory structure. Modules are identified by a combination of the author's username and the module's name, separated by a hyphen. For example: `puppetlabs-apache` * **Release**: A single, specific version of a module is called a Release. Releases are identified by a combination of the module identifier (see above) and the Release version, separated by a hyphen. For example: `puppetlabs-apache-4.0.0`  ## Errors The Puppet Forge API follows [RFC 2616](https://tools.ietf.org/html/rfc2616) and [RFC 6585](https://tools.ietf.org/html/rfc6585).  Error responses are served with a `4xx` or `5xx` status code, and are sent as a JSON document with a content type of `application/json`. The error document contains the following top-level keys and values:    * `message`: a string value that summarizes the problem   * `errors`: a list (array) of strings containing additional details describing the underlying cause(s) of the     failure  An example error response is shown below:  ```json {   \"message\": \"400 Bad Request\",   \"errors\": [     \"Cannot parse request body as JSON\"   ] } ```  ## User-Agent Required All API requests must include a valid `User-Agent` header. Requests with no `User-Agent` header will be rejected. The `User-Agent` header helps identify your application or library, so we can communicate with you if necessary. If your use of the API is informal or personal, we recommend using your username as the value for the `User-Agent` header.  User-Agent headers are a list of one or more product descriptions, generally taking this form:  ``` <name-without-spaces>/<version> (comments) ```  For example, the following are all useful User-Agent values:  ``` MyApplication/0.0.0 Her/0.6.8 Faraday/0.8.8 Ruby/1.9.3-p194 (i386-linux) My-Library-Name/1.2.4 myusername ```  ## Hostname Configuration Most tools that interact with the Forge API allow specification of the hostname to use. You can configure a few common tools to use a specified hostname as follows:  For **Puppet Enterprise** users, in [r10k](https://puppet.com/docs/pe/latest/r10k_customize_config.html#r10k_configuring_forge_settings) or [Code Manager](https://puppet.com/docs/pe/latest/code_mgr_customizing.html#config_forge_settings), specify `forge_settings` in Hiera: ``` pe_r10k::forge_settings:   baseurl: 'https://forgeapi.puppet.com' ``` or ``` puppet_enterprise::master::code_manager::forge_settings:   baseurl: 'https://forgeapi.puppet.com' ``` <br />  If you are an **open source Puppet** user using r10k, you'll need to [edit your r10k.yaml directly](https://github.com/puppetlabs/r10k/blob/main/doc/dynamic-environments/configuration.mkd#forge): ``` forge:   baseurl: 'https://forgeapi.puppet.com' ``` or set the appropriate class param for the [open source r10k module](https://forge.puppet.com/puppet/r10k#forge_settings): ``` $forge_settings = {   'baseurl' => 'https://forgeapi.puppet.com', } ``` <br />  In [**Bolt**](https://puppet.com/docs/bolt/latest/bolt_installing_modules.html#install-forge-modules-from-an-alternate-forge), set a `baseurl` for the Forge in `bolt-project.yaml`: ``` module-install:   forge:     baseurl: https://forgeapi.puppet.com ``` <br />  Using `puppet config`: ``` $ puppet config set module_repository https://forgeapi.puppet.com ``` 
 *
 * API version: 29
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package gorge

import (
	"encoding/json"
	"net/http"
	"strings"

	"github.com/go-chi/chi/v5"
)

// ModuleOperationsAPIController binds http requests to an api service and writes the service results to the http response
type ModuleOperationsAPIController struct {
	service ModuleOperationsAPIServicer
	errorHandler ErrorHandler
}

// ModuleOperationsAPIOption for how the controller is set up.
type ModuleOperationsAPIOption func(*ModuleOperationsAPIController)

// WithModuleOperationsAPIErrorHandler inject ErrorHandler into controller
func WithModuleOperationsAPIErrorHandler(h ErrorHandler) ModuleOperationsAPIOption {
	return func(c *ModuleOperationsAPIController) {
		c.errorHandler = h
	}
}

// NewModuleOperationsAPIController creates a default api controller
func NewModuleOperationsAPIController(s ModuleOperationsAPIServicer, opts ...ModuleOperationsAPIOption) Router {
	controller := &ModuleOperationsAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the ModuleOperationsAPIController
func (c *ModuleOperationsAPIController) Routes() Routes {
	return Routes{
		"DeleteModule": Route{
			strings.ToUpper("Delete"),
			"/v3/modules/{module_slug}",
			c.DeleteModule,
		},
		"DeprecateModule": Route{
			strings.ToUpper("Patch"),
			"/v3/modules/{module_slug}",
			c.DeprecateModule,
		},
		"GetModule": Route{
			strings.ToUpper("Get"),
			"/v3/modules/{module_slug}",
			c.GetModule,
		},
		"GetModules": Route{
			strings.ToUpper("Get"),
			"/v3/modules",
			c.GetModules,
		},
	}
}

// DeleteModule - Delete module
func (c *ModuleOperationsAPIController) DeleteModule(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	moduleSlugParam := chi.URLParam(r, "module_slug")
	if moduleSlugParam == "" {
		c.errorHandler(w, r, &RequiredError{"module_slug"}, nil)
		return
	}
	var reasonParam string
	if query.Has("reason") {
		param := query.Get("reason")

		reasonParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "reason"}, nil)
		return
	}
	result, err := c.service.DeleteModule(r.Context(), moduleSlugParam, reasonParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeprecateModule - Deprecate module
func (c *ModuleOperationsAPIController) DeprecateModule(w http.ResponseWriter, r *http.Request) {
	moduleSlugParam := chi.URLParam(r, "module_slug")
	if moduleSlugParam == "" {
		c.errorHandler(w, r, &RequiredError{"module_slug"}, nil)
		return
	}
	deprecationRequestParam := DeprecationRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&deprecationRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertDeprecationRequestRequired(deprecationRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertDeprecationRequestConstraints(deprecationRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.DeprecateModule(r.Context(), moduleSlugParam, deprecationRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetModule - Fetch module
func (c *ModuleOperationsAPIController) GetModule(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	moduleSlugParam := chi.URLParam(r, "module_slug")
	if moduleSlugParam == "" {
		c.errorHandler(w, r, &RequiredError{"module_slug"}, nil)
		return
	}
	var withHtmlParam bool
	if query.Has("with_html") {
		param, err := parseBoolParameter(
			query.Get("with_html"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		withHtmlParam = param
	} else {
	}
	var includeFieldsParam []string
	if query.Has("include_fields") {
		includeFieldsParam = strings.Split(query.Get("include_fields"), ",")
	}
	var excludeFieldsParam []string
	if query.Has("exclude_fields") {
		excludeFieldsParam = strings.Split(query.Get("exclude_fields"), ",")
	}
	ifModifiedSinceParam := r.Header.Get("If-Modified-Since")
	result, err := c.service.GetModule(r.Context(), moduleSlugParam, withHtmlParam, includeFieldsParam, excludeFieldsParam, ifModifiedSinceParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetModules - List modules
func (c *ModuleOperationsAPIController) GetModules(w http.ResponseWriter, r *http.Request) {
	query, err := parseQuery(r.URL.RawQuery)
	if err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](1),
			WithMaximum[int32](100),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
		var param int32 = 20
		limitParam = param
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
			WithMinimum[int32](0),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
		var param int32 = 0
		offsetParam = param
	}
	var sortByParam string
	if query.Has("sort_by") {
		param := query.Get("sort_by")

		sortByParam = param
	} else {
	}
	var queryParam string
	if query.Has("query") {
		param := query.Get("query")

		queryParam = param
	} else {
	}
	var tagParam string
	if query.Has("tag") {
		param := query.Get("tag")

		tagParam = param
	} else {
	}
	var ownerParam string
	if query.Has("owner") {
		param := query.Get("owner")

		ownerParam = param
	} else {
	}
	var withTasksParam bool
	if query.Has("with_tasks") {
		param, err := parseBoolParameter(
			query.Get("with_tasks"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		withTasksParam = param
	} else {
	}
	var withPlansParam bool
	if query.Has("with_plans") {
		param, err := parseBoolParameter(
			query.Get("with_plans"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		withPlansParam = param
	} else {
	}
	var withPdkParam bool
	if query.Has("with_pdk") {
		param, err := parseBoolParameter(
			query.Get("with_pdk"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		withPdkParam = param
	} else {
	}
	var premiumParam bool
	if query.Has("premium") {
		param, err := parseBoolParameter(
			query.Get("premium"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		premiumParam = param
	} else {
	}
	var excludePremiumParam bool
	if query.Has("exclude_premium") {
		param, err := parseBoolParameter(
			query.Get("exclude_premium"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		excludePremiumParam = param
	} else {
	}
	var endorsementsParam []string
	if query.Has("endorsements") {
		endorsementsParam = strings.Split(query.Get("endorsements"), ",")
	}
	var operatingsystemParam string
	if query.Has("operatingsystem") {
		param := query.Get("operatingsystem")

		operatingsystemParam = param
	} else {
	}
	var operatingsystemreleaseParam string
	if query.Has("operatingsystemrelease") {
		param := query.Get("operatingsystemrelease")

		operatingsystemreleaseParam = param
	} else {
	}
	var peRequirementParam string
	if query.Has("pe_requirement") {
		param := query.Get("pe_requirement")

		peRequirementParam = param
	} else {
	}
	var puppetRequirementParam string
	if query.Has("puppet_requirement") {
		param := query.Get("puppet_requirement")

		puppetRequirementParam = param
	} else {
	}
	var withMinimumScoreParam int32
	if query.Has("with_minimum_score") {
		param, err := parseNumericParameter[int32](
			query.Get("with_minimum_score"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		withMinimumScoreParam = param
	} else {
	}
	var moduleGroupsParam []string
	if query.Has("module_groups") {
		moduleGroupsParam = strings.Split(query.Get("module_groups"), ",")
	}
	var showDeletedParam bool
	if query.Has("show_deleted") {
		param, err := parseBoolParameter(
			query.Get("show_deleted"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		showDeletedParam = param
	} else {
	}
	var hideDeprecatedParam bool
	if query.Has("hide_deprecated") {
		param, err := parseBoolParameter(
			query.Get("hide_deprecated"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		hideDeprecatedParam = param
	} else {
	}
	var onlyLatestParam bool
	if query.Has("only_latest") {
		param, err := parseBoolParameter(
			query.Get("only_latest"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		onlyLatestParam = param
	} else {
		var param bool = false
		onlyLatestParam = param
	}
	var slugsParam []string
	if query.Has("slugs") {
		slugsParam = strings.Split(query.Get("slugs"), ",")
	}
	var withHtmlParam bool
	if query.Has("with_html") {
		param, err := parseBoolParameter(
			query.Get("with_html"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		withHtmlParam = param
	} else {
	}
	var includeFieldsParam []string
	if query.Has("include_fields") {
		includeFieldsParam = strings.Split(query.Get("include_fields"), ",")
	}
	var excludeFieldsParam []string
	if query.Has("exclude_fields") {
		excludeFieldsParam = strings.Split(query.Get("exclude_fields"), ",")
	}
	ifModifiedSinceParam := r.Header.Get("If-Modified-Since")
	var startsWithParam string
	if query.Has("starts_with") {
		param := query.Get("starts_with")

		startsWithParam = param
	} else {
	}
	var supportedParam bool
	if query.Has("supported") {
		param, err := parseBoolParameter(
			query.Get("supported"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		supportedParam = param
	} else {
	}
	var withReleaseSinceParam string
	if query.Has("with_release_since") {
		param := query.Get("with_release_since")

		withReleaseSinceParam = param
	} else {
	}
	result, err := c.service.GetModules(r.Context(), limitParam, offsetParam, sortByParam, queryParam, tagParam, ownerParam, withTasksParam, withPlansParam, withPdkParam, premiumParam, excludePremiumParam, endorsementsParam, operatingsystemParam, operatingsystemreleaseParam, peRequirementParam, puppetRequirementParam, withMinimumScoreParam, moduleGroupsParam, showDeletedParam, hideDeprecatedParam, onlyLatestParam, slugsParam, withHtmlParam, includeFieldsParam, excludeFieldsParam, ifModifiedSinceParam, startsWithParam, supportedParam, withReleaseSinceParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}
